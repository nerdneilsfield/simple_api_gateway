# 运维与监控

<cite>
**本文档引用的文件**   
- [main.go](file://main.go)
- [cmd/root.go](file://cmd/root.go)
- [cmd/serve.go](file://cmd/serve.go)
- [cmd/check.go](file://cmd/check.go)
- [internal/config/config.go](file://internal/config/config.go)
- [internal/router/router.go](file://internal/router/router.go)
- [internal/cache/cache.go](file://internal/cache/cache.go)
- [internal/loadbalancer/loadbalancer.go](file://internal/loadbalancer/loadbalancer.go)
- [scripts/systemctl/simple-api-gateway@.service](file://scripts/systemctl/simple-api-gateway@.service)
- [scripts/rc/simple_api_gateway](file://scripts/rc/simple_api_gateway)
- [example_config.toml](file://example_config.toml)
- [config-with-redis.toml](file://config-with-redis.toml)
- [config-without-redis.toml](file://config-without-redis.toml)
- [README.md](file://README.md)
</cite>

## 目录
1. [服务管理](#服务管理)
2. [信号处理与优雅关闭](#信号处理与优雅关闭)
3. [日志系统](#日志系统)
4. [监控指标](#监控指标)
5. [配置热加载](#配置热加载)
6. [故障诊断](#故障诊断)
7. [性能调优](#性能调优)

## 服务管理

`simple_api_gateway` 提供了多种方式来启动、停止和重启服务实例。服务通过 `serve` 命令启动，并接受一个配置文件作为参数。

**启动服务**:
```bash
simple-api-gateway serve /path/to/config.toml
```

**停止服务**:
可以通过发送 `SIGTERM` 或 `Interrupt` 信号来停止正在运行的服务实例。

**重启服务**:
重启服务可以通过先停止再启动来实现，或者在支持的系统上使用服务管理命令。

该服务支持通过 `systemd` 和 OpenRC 进行系统级管理。`scripts/systemctl/` 目录下的 `simple-api-gateway@.service` 文件定义了 `systemd` 服务单元，而 `scripts/rc/` 目录下的 `simple_api_gateway` 文件则用于 OpenRC 系统。

**systemd 服务示例**:
```ini
[Unit]
Description=Simple API Gateway Service for %I
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/bin/simple_api_gateway cron /etc/simple_api_gateway/%i.toml
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
```

**OpenRC 服务示例**:
```bash
#!/sbin/openrc-run

name="simple_api_gateway"
description="Simple API Gateway Service"
command="/usr/bin/simple_api_gateway"
command_args="cron /etc/simple_api_gateway/${RC_SVCNAME#simple_api_gateway.}.toml"
pidfile="/run/${RC_SVCNAME}.pid"
command_background="yes"

depend() {
    need net
    after firewall
}

start_pre() {
    ebegin "Waiting for network to be fully online"
    eend $?
}
```

**Section sources**
- [cmd/serve.go](file://cmd/serve.go#L10-L30)
- [scripts/systemctl/simple-api-gateway@.service](file://scripts/systemctl/simple-api-gateway@.service#L1-L13)
- [scripts/rc/simple_api_gateway](file://scripts/rc/simple_api_gateway#L1-L18)

## 信号处理与优雅关闭

`simple_api_gateway` 实现了优雅关闭机制，以确保在服务终止前能够完成正在进行的请求并释放资源。该机制通过监听 `SIGTERM` 和 `Interrupt` 信号来触发。

在 `main.go` 文件中，程序启动时会创建一个信号通道并注册对 `os.Interrupt` 和 `syscall.SIGTERM` 信号的监听。当接收到这些信号时，会启动一个 goroutine 来执行 `gracefulShutdown` 函数。

```go
func main() {
	signalChan := make(chan os.Signal, 1)
	signal.Notify(signalChan, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-signalChan
		gracefulShutdown()
		os.Exit(0)
	}()

	if err := cmd.Execute(version, buildTime, gitCommit); err != nil {
		logger.Error("Failed to execute root command", zap.Error(err))
		os.Exit(1)
	}
}
```

`gracefulShutdown` 函数负责记录关闭日志，并同步和关闭日志系统，确保所有日志条目都被正确写入。

```go
func gracefulShutdown() {
	logger.Info("Shutting down...")
	logger.SyncLogs()
	logger.Close()
}
```

此外，在 `router.go` 的 `Run` 函数中，当缓存管理器被初始化后，会设置一个 `defer` 语句来确保在服务器停止时关闭缓存连接。

```go
defer func() {
	logger.Info("Closing cache manager")
	cacheManager.Close()
}()
```

**Section sources**
- [main.go](file://main.go#L27-L48)
- [internal/router/router.go](file://internal/router/router.go#L470-L473)

## 日志系统

`simple_api_gateway` 使用 `zap` 库进行结构化日志记录，提供了详细的日志信息，便于监控和故障排查。日志级别包括 `Debug`、`Info`、`Warn`、`Error` 和 `Fatal`。

### 日志格式规范

日志条目以 JSON 格式输出，包含时间戳、日志级别、消息以及结构化的字段。例如：

```json
{
  "level": "info",
  "ts": 1730880000.123,
  "msg": "Starting server",
  "address": "0.0.0.0:8080"
}
```

### 关键日志条目解读

- **请求日志**:
  - `Handling request`: 记录每个请求的路径、方法和路由。
  - `Request completed`: 记录请求完成的总时间、状态码和处理时间。
  - `Cache hit` / `Cache miss`: 记录缓存命中或未命中的情况。

- **错误日志**:
  - `Failed to parse config`: 配置文件解析失败。
  - `route backend is not a valid URL`: 后端服务 URL 无效。
  - `Backend request failed`: 向后端服务发送请求失败。
  - `Failed to initialize cache manager`: 缓存管理器初始化失败。

- **性能日志**:
  - `Initializing cache manager`: 记录缓存管理器的初始化时间和使用的缓存类型（Redis 或内存）。
  - `Backend reported success`: 记录后端请求的成功响应时间和状态。
  - `Response cached successfully`: 记录响应成功缓存的时间和 TTL。

**Section sources**
- [internal/router/router.go](file://internal/router/router.go#L283-L322)
- [internal/cache/cache.go](file://internal/cache/cache.go#L78-L243)
- [internal/loadbalancer/loadbalancer.go](file://internal/loadbalancer/loadbalancer.go#L131-L162)

## 监控指标

为了有效监控 `simple_api_gateway` 的运行状态，建议采集以下关键指标：

### 请求延迟
- **指标**: 请求处理时间 (`requestDuration`)
- **采集方法**: 从 `Request completed` 日志条目中提取 `totalTime` 字段。
- **建议**: 计算平均延迟、P95 和 P99 延迟，以评估服务性能。

### 错误率
- **指标**: HTTP 5xx 错误率
- **采集方法**: 统计 `Backend request failed` 和 `handleBackendRequest` 返回 5xx 状态码的日志条目。
- **建议**: 监控错误率的变化趋势，及时发现后端服务问题。

### 缓存命中率
- **指标**: 缓存命中率
- **采集方法**: 统计 `Cache hit` 和 `Cache miss` 日志条目的数量。
- **计算公式**: `Cache hit rate = Cache hits / (Cache hits + Cache misses)`
- **建议**: 高缓存命中率可以显著降低后端负载和响应延迟。

### 其他建议指标
- **QPS (Queries Per Second)**: 每秒请求数，从日志中统计请求频率。
- **后端健康状态**: 从负载均衡器的日志中获取健康后端的数量。
- **内存使用**: 监控进程的内存占用，特别是在使用内存缓存时。

**Section sources**
- [internal/router/router.go](file://internal/router/router.go#L317-L322)
- [internal/cache/cache.go](file://internal/cache/cache.go#L371-L398)
- [internal/loadbalancer/loadbalancer.go](file://internal/loadbalancer/loadbalancer.go#L131-L162)

## 配置热加载

根据当前代码分析，`simple_api_gateway` **不支持**配置热加载。服务在启动时读取一次配置文件，并在运行期间保持不变。任何配置更改都需要重启服务才能生效。

在 `cmd/serve.go` 的 `newServeCmd` 函数中，配置文件在 `RunE` 函数开始时被解析和验证，之后没有机制来监听文件变化或重新加载配置。

```go
RunE: func(cmd *cobra.Command, args []string) error {
	logger.Info("serve the api gateway", zap.String("config", args[0]))
	config_, err := config.ParseConfig(args[0])
	if err != nil {
		return err
	}
	if err := config.ValidateConfig(config_); err != nil {
		return err
	}
	router.Run(config_)
	return nil
},
```

因此，配置热加载的限制是：必须通过重启服务来应用新的配置更改。

**Section sources**
- [cmd/serve.go](file://cmd/serve.go#L16-L27)

## 故障诊断

### 后端服务不可达
- **症状**: 日志中频繁出现 `Backend request failed` 和 `Backend marked as unhealthy`。
- **诊断步骤**:
  1. 检查 `config.toml` 文件中后端服务的 URL 是否正确。
  2. 使用 `ping` 或 `curl` 命令测试后端服务的网络连通性。
  3. 检查后端服务是否正常运行。
  4. 查看防火墙设置，确保端口开放。
- **解决方案**: 修正配置中的 URL，或确保后端服务可用。

### 缓存失效
- **症状**: 缓存命中率低，`Cache miss` 日志频繁出现。
- **诊断步骤**:
  1. 检查 `cache.enabled` 和 `route.cache_enable` 配置是否为 `true`。
  2. 确认 `cache_ttl` 是否设置为大于 0 的值。
  3. 检查 `cache_paths` 配置是否与请求路径匹配。
  4. 如果使用 Redis，检查 Redis 服务是否正常运行，连接 URL 是否正确。
- **解决方案**: 调整缓存配置，确保缓存条件满足。

### 性能瓶颈
- **症状**: 请求延迟高，QPS 低。
- **诊断步骤**:
  1. 检查后端服务的响应时间，确认瓶颈是否在后端。
  2. 监控 CPU 和内存使用率，确认网关自身资源是否充足。
  3. 检查网络带宽和延迟。
  4. 分析日志，查看是否有大量错误或重试。
- **解决方案**: 优化后端服务，增加网关实例进行负载均衡，或调整缓存策略。

**Section sources**
- [internal/config/config.go](file://internal/config/config.go#L216-L221)
- [internal/router/router.go](file://internal/router/router.go#L230-L235)
- [internal/loadbalancer/loadbalancer.go](file://internal/loadbalancer/loadbalancer.go#L153-L158)

## 性能调优

### 配置参数调优
- **缓存 TTL (`cache_ttl`)**: 根据数据的更新频率设置合适的 TTL。对于不常变化的数据，可以设置较长的 TTL 以提高缓存命中率。
- **负载均衡**: 当前使用轮询（Round-Robin）策略。可以通过调整 `maxFailCount` 和 `failTimeout` 参数来优化故障转移行为。
- **日志级别**: 在生产环境中，将日志级别设置为 `Info` 或 `Warn`，以减少日志输出对性能的影响。可以通过 `--verbose` 标志启用详细日志。

### 资源管理
- **内存**: 如果使用内存缓存，需监控内存使用情况，避免内存溢出。考虑使用 Redis 作为外部缓存以减轻内存压力。
- **连接池**: 虽然代码中未显式配置，但底层 HTTP 客户端（如 `fiber`）通常有连接池。确保连接池大小适合预期的并发量。
- **并发处理**: `simple_api_gateway` 基于 Go 的并发模型，能够高效处理大量并发请求。确保服务器有足够的 CPU 资源。

通过合理配置这些参数，可以显著提升 `simple_api_gateway` 的性能和稳定性。

**Section sources**
- [internal/config/config.go](file://internal/config/config.go#L41-L42)
- [internal/loadbalancer/loadbalancer.go](file://internal/loadbalancer/loadbalancer.go#L65-L66)
- [cmd/root.go](file://cmd/root.go#L24-L27)